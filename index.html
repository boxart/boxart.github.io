<html>
<head><link href="main.css" rel="stylesheet"></head>
<body><div><div><h1>BoxArt</h1>
<p><a href="refs/">API Documentation</a></p>
<h2>Usage</h2>
<p>BoxArt is a state-ful animate-on-class-change library. It starts an animation when an element it is watching changes its class list. BoxArt currently animates html elements by listening to mutation observer events, React's virtual dom, or Preact's virtual dom.</p>
<h4>DOM Usage:</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> animations = {
  <span class="hljs-string">'animatedType'</span>: {
    <span class="hljs-attr">default</span>: <span class="hljs-comment">// ...</span>
  },
};

<span class="hljs-keyword">new</span> BoxArtMutation({animations})
.observe(<span class="hljs-built_in">document</span>.body);
</code></pre>
<p class="full"><a class="jsbin-embed" href="https://jsbin.com/bobidus/embed?js,output">JS Bin on jsbin.com</a></p>
<h4>React/Preact usage:</h4>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">BoxArt</span> <span class="hljs-attr">animations</span>=<span class="hljs-string">{animations}</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">BoxArt</span>&gt;</span>
</code></pre>
<p class="full"><a class="jsbin-embed" href="https://jsbin.com/hireyac/embed?js,output">JS Bin on jsbin.com</a></p>
<script src="https://static.jsbin.com/js/embed.min.js?4.1.4"></script>
</div><div><h2>Classful Animations</h2>
<p>BoxArt animations respond to changes in an animated element's location in the DOM, not spatial position, or its class list. Animating elements are identified by up to 3 names in their class list. The three names are the animation <code>type</code>, the element's <code>id</code>, and the current <code>animation</code>. The <code>type</code> determines what <code>animation</code>s are available to a given element. At minimum an element can animate with only the <code>type</code> in its class list. The <code>id</code> defaults to the <code>type</code>. Other <code>id</code>s are the <code>type</code> with any suffix. <code>animation</code> defaults to <code>default</code>.</p>
<p>An animation is run with three state objects, a beginning state, an end state, and a modifiable state. An animation works by updating these states from the DOM or javascript values, animating the modifiable state between the begin and end states, and presenting the modifiable state on the element and its children. The animating element's <code>id</code> indicates what set of states with that element. This lets elements move in the DOM's hierarchy or for a new element to reuse an old element's state.</p>
</div><div><h2>Animation Functions</h2>
<p>BoxArt provides a family of functions as shorthand for creating its animation functions. They fall into three families: <code>update</code>, <code>animate</code>, and <code>present</code>.</p>
<p>As mentioned <code>update</code> functions update the state objects BoxArt uses. <code>animate</code> functions animate a third state object between the first two. <code>present</code> functions present the third state on the animated element.</p>
<p><a name="update"><a href="#update"></p>
<h3>update</h3>
<p></a></a></p>
<pre><code class="language-js">update: update.rect().asElement(update.object({
  <span class="hljs-attr">left</span>: update.property(<span class="hljs-string">'left'</span>),
  <span class="hljs-attr">top</span>: update.property(<span class="hljs-string">'top'</span>),
})),
</code></pre>
<p>BoxArt's function shorthand allows for some chaining but this can also be written:</p>
<pre><code class="language-js">update: update.asElement(update.rect(), update.object({
  <span class="hljs-attr">left</span>: update.property(<span class="hljs-string">'left'</span>),
  <span class="hljs-attr">top</span>: update.property(<span class="hljs-string">'top'</span>),
})),
</code></pre>
<p>Lets break down what this function is doing.</p>
<p>The returned function takes three arguments <code>state</code>, <code>element</code>, and <code>data</code> and returns its final <code>state</code>.</p>
<p>Written out the above might look like:</p>
<pre><code class="language-js">update: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state, element, data</span>) </span>{
    element = element.getBoundingClientRect();
    state = state || {};
    state.left = element.left;
    state.top = element.top;
    <span class="hljs-keyword">return</span> state;
  };
}()),
</code></pre>
<p>This function is using the element's client rectangle to build a left and top state. In addition to the main function, update has a few helper functions <code>copy</code>, <code>merge</code> and <code>should</code>. <code>copy</code> and <code>merge</code> are used to update the animation states without querying the element when it isn't necessary or desired. <code>should</code> if given shortcuts animations if it returns false.</p>
<p>Our update written with its helpers would be:</p>
<pre><code class="language-js">update: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state, element, data</span>) </span>{
    element = element.getBoundingClientRect();
    state = state || {};
    state.left = element.left;
    state.top = element.top;
    <span class="hljs-keyword">return</span> state;
  };
  func.copy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dest, src</span>) </span>{
    dest = dest || {};
    dest.left = src.left;
    dest.top = src.top;
    <span class="hljs-keyword">return</span> dest;
  };
  <span class="hljs-comment">// This example creates a merge that is the same as copy.</span>
  func.merge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dest, src</span>) </span>{
    dest = dest || {};
    dest.left = src.left;
    dest.top = src.top;
    <span class="hljs-keyword">return</span> dest;
  };
  <span class="hljs-comment">// This example normally does not have a should but here is a barebones</span>
  <span class="hljs-comment">// example.</span>
  func.should = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stateA, stateB</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };
  <span class="hljs-keyword">return</span> func;
}()),
</code></pre>
<h3>animate</h3>
<pre><code class="language-js">animate: animate.object({
  <span class="hljs-attr">left</span>: animate.begin().to(animate.end()),
  <span class="hljs-attr">top</span>: animate.top().to(animate.end()),
}),
</code></pre>
<p><code>animate</code> functions like <code>update</code>'s may chain. This function expands to:</p>
<pre><code class="language-js">animate: animate.object({
  <span class="hljs-attr">left</span>: animate.to(animate.begin(), animate.end()),
  <span class="hljs-attr">top</span>: animate.to(animate.begin(), animate.end()),
}),
</code></pre>
<p><code>animate</code> functions slightly break a rule in the order of arguments to BoxArt animation functions. The first argument in most BoxArt functions is the destination for values. Animation functions instead pass a time value <code>t</code>. <code>t</code> starts as the number of seconds since the start of the animation but normally is transformed by easing functions into a value between 0 and 1. The other arguments are <code>state</code>, <code>begin</code>, <code>end</code> and <code>data</code>.</p>
<p>With its <code>done</code> helper function that by its namesake determines when the animation is done, the example <code>animate</code> function handwritten may look like:</p>
<pre><code class="language-js">animate: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, state, begin, end, data</span>) </span>{
    state.left = (end.left - begin.left) * t + begin.left;
    state.top = (end.top - begin.top) * t + begin.top;
  };
  func.done = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>{
    <span class="hljs-keyword">return</span> t &gt;= <span class="hljs-number">1</span>;
  };
  <span class="hljs-keyword">return</span> func;
}()),
</code></pre>
<h3>present</h3>
<p><code>update</code> and <code>animate</code> functions share their shape around the defined data structure for an animation. <code>present</code> will use that data structure to change how the animated element is presented.</p>
<pre><code class="language-js">present: present.style({
  <span class="hljs-attr">transform</span>: present.translate([
    present.key(<span class="hljs-string">'left'</span>).to(present.end).px(),
    present.key(<span class="hljs-string">'top'</span>).to(present.end).px(),
  ]),
}),
</code></pre>
<p><code>present</code> functions commonly expand more than <code>update</code> and <code>animate</code>.</p>
<pre><code class="language-js">present: present.style({
  <span class="hljs-attr">transform</span>: present.translate([
    present.px(present.sub(present.key(<span class="hljs-string">'left'</span>), present.end(present.key(<span class="hljs-string">'left'</span>)))),
    present.px(present.sub(present.key(<span class="hljs-string">'top'</span>), present.end(present.key(<span class="hljs-string">'top'</span>)))),
  ]),
}),
</code></pre>
<p>This <code>present</code> function is creating a difference on the <code>left</code> and <code>top</code> keys so that the transform is relative to where the element should current render.</p>
<p>Since <code>present</code> functions may overwrite the current presentation of an element, the helpers create some functions used to <code>store</code> and <code>restore</code> the original values that may be overwritten. Together these functions follow <code>update</code>'s argument layout where the value being modified is the first.</p>
<p><code>present</code> takes 3 arguments: <code>element</code>, <code>state</code>, and <code>data</code>. Our example might look like:</p>
<pre><code class="language-js">present: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, state, data</span>) </span>{
    <span class="hljs-keyword">const</span> end = data.end;
    element.style.transform =
      <span class="hljs-string">`translate(<span class="hljs-subst">${state.left - end.left}</span>px, <span class="hljs-subst">${state.top - end.top}</span>px)`</span>;
  };
}()),
</code></pre>
<p><code>store</code> like <code>update</code> initializes and stores its target data with arguments <code>store</code>, <code>element</code>, and <code>data</code>. <code>restore</code> swaps the first two arguments and takes <code>element</code>, <code>store</code>, and <code>data</code>.</p>
<pre><code class="language-js">present: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, state, data</span>) </span>{
    <span class="hljs-keyword">const</span> end = data.end;
    element.style.transform =
      <span class="hljs-string">`translate(<span class="hljs-subst">${state.left - end.left}</span>px, <span class="hljs-subst">${state.top - end.top}</span>px)`</span>;
  };
  func.store = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">store, element, data</span>) </span>{
    store = store || {};
    <span class="hljs-keyword">const</span> style = store.style = store.style || {};
    style.transform = element.style.transform;
    <span class="hljs-keyword">return</span> store;
  };
  func.restore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, store, data</span>) </span>{
    element.style.transform = store.style.transform;
  };
  <span class="hljs-keyword">return</span> func;
}()),
</code></pre>
</div><div><h2>Animated State Machine</h2>
<p>The animation functions are used by an animated state machine. The object tracks the current <code>animation</code> class name of an animated element. When the element is updated to the current <code>animation</code> class name, it updates end, stores the presentation and starts animating and presenting the updated modifiable state. The first animation also copies the <code>end</code> state into the <code>begin</code> and <code>state</code> state. These values, the element being animated and the time <code>t</code> make up the <code>data</code> argument stored by the animated state machine and passed to most of the animation functions.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.data = {
  <span class="hljs-attr">animated</span>: {
    <span class="hljs-attr">root</span>: {
      <span class="hljs-attr">element</span>: <span class="hljs-comment">// HTMLElement</span>
    },
  },
  <span class="hljs-attr">t</span>: <span class="hljs-comment">// Time in seconds</span>
  state: <span class="hljs-comment">// The modifiable state</span>
  begin: <span class="hljs-comment">// The beginning state</span>
  end: <span class="hljs-comment">// The target end state</span>
  store: <span class="hljs-comment">// The stored possibly overwritten presentation</span>
};
</code></pre>
<p>With a reference to an <code>AnimatedManager</code> the state machine for an element by its <code>type</code> and <code>id</code>.</p>
</div><div><h2>React/Preact enter and leave Animations</h2>
<p>React and Preact integrations support animated elements having a enter and leave <code>animation</code> used when the element enters and leaves the virtual dom.</p>
<p>These animations normally need <code>animate</code> functions with <code>constant</code> values to help and <code>leave</code> animations need a little CSS to help.</p>
<p>We can create an example that fades in and out.</p>
<pre><code class="language-js">enter: {
  <span class="hljs-attr">update</span>: update.rect().asElement(update.object({
    <span class="hljs-attr">opacity</span>: animate.constant(<span class="hljs-number">0</span>),
  })),
  <span class="hljs-attr">animate</span>: animate.object({
    <span class="hljs-attr">opacity</span>: animate.constant(<span class="hljs-number">0</span>).to(animate.end()),
  }),
  <span class="hljs-attr">present</span>: present.style({
    <span class="hljs-attr">opacity</span>: present.key(<span class="hljs-string">'opacity'</span>),
  }),
},
</code></pre>
<pre><code class="language-js">leave: {
  <span class="hljs-attr">update</span>: update.rect().asElement(update.object({
    <span class="hljs-attr">opacity</span>: animate.constant(<span class="hljs-number">0</span>),
  })),
  <span class="hljs-attr">animate</span>: animate.object({
    <span class="hljs-attr">opacity</span>: animate.begin().to(animate.constant(<span class="hljs-number">0</span>)),
  }),
  <span class="hljs-attr">present</span>: present.style({
    <span class="hljs-attr">opacity</span>: present.key(<span class="hljs-string">'opacity'</span>),
  }),
},
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.animatedType</span> <span class="hljs-selector-class">.leave</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
}
</code></pre>
</div></div><script type="text/javascript" src="main.js"></script></body>
</html>